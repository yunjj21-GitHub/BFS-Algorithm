// 백준 16954 : 움직이는 미로 탈출
#include <vector>
#include <string>
#include <queue>
#include <iostream>

using namespace std;

// 제자리, 상, 하, 좌, 우, 대각선_상좌, 대각선_상우, 대각선_하좌, 대각선_하우 
int dx[9] = { 0, 0, 0, 1, -1, -1, 1, -1, 1};
int dy[9] = { 0, -1, 1, 0, 0, -1, -1, 1, 1};

int main() {
	vector<pair<int, int>> wall;
	char map[10][10];
	for (int i = 1; i <= 8; i++) {
		for (int j = 1; j <= 8; j++) {
			cin >> map[i][j];
			if (map[i][j] == '#') wall.push_back({ i, j }); // {y, x}
		}
	}

	queue<vector<int>> q;
	q.push({ 8, 1, 1 }); // 욱제의 위치 y, x, 노드의 깊이
	int depth = 1;
	while (!q.empty()) {
		// 욱제의 움직임
		int y = q.front()[0];
		int x = q.front()[1];
		int cur_depth = q.front()[2];
		q.pop();

		if (y == 1 && x == 8) {
			cout << 1 << '\n';
			return 0;
		}

		if (cur_depth != depth) {
			depth++;

			// map 갱신
			for (int i = wall.size() - 1; i >= 0; i--) {
				map[wall[i].first][wall[i].second] = '.';
				if (wall[i].first == 8) continue;

				wall[i].first++;
				map[wall[i].first][wall[i].second] = '#';
			}

			// 더이상 벽이 없다면
			int cnt = 0;
			for (int i = 1; i <= 8; i++) {
				for (int j = 1; j <= 8; j++) {
					if (map[i][j] == '.') cnt++;
				}
			}
			if (cnt == 8 * 8) {
				cout << 1 << '\n';
				return 0;
			}
		}

		if (map[y][x] == '#') continue;

 		for (int i = 0; i < 9; i++) {
			int nextY = y + dy[i];
			int nextX = x + dx[i];

			if (1 <= nextY && nextY <= 8 && 1 <= nextX && nextX <= 8) {
				if (map[nextY][nextX] != '#') { // 갔던 곳 다시 갈 수 있음
					q.push({ nextY , nextX, cur_depth + 1 });
				}
			}
		}
	}
	cout << 0 << '\n';
	return 0;
}