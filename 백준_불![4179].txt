// 백준 4179 : 불! (지훈이가 움직이고 불이 움직여야 예시가 성립)
#include <vector>
#include <string>
#include <iostream>
#include <queue>

using namespace std;

int R, C;
char map[1002][1002];
queue<vector<int>> q;
bool chk[1002][1002];
int dy[4] = { 0, 0, 1, -1 };
int dx[4] = { 1, -1, 0, 0 };

int main() {
	cin >> R >> C;
	vector<pair<int, int>> fire_palce;
	for (int i = 1; i <= R; i++) {
		for (int j = 1; j <= C; j++) {
			cin >> map[i][j];

			if (map[i][j] == 'J') q.push({ i, j, 0 }); // {y, x, time}
			else if (map[i][j] == 'F') fire_palce.push_back({ i , j }); // {y, x}
		}
	}
	
	for (auto place : fire_palce) {
		q.push({ place.first, place.second, -1 });
	}

	// BFS 탐색 (지훈이가 움직이고 불이 움직이게 된다.)
	while (!q.empty()) {
		int y = q.front()[0];
		int x = q.front()[1];
		int time = q.front()[2];
		q.pop();

		// 지훈이가 탈출했는지 확인
		if (map[y][x] == 'J') {
			if (y == 0 || y == R + 1 || x == 0 || x == C + 1) {
				cout << time << '\n';
				return 0;
			}
		}
		
		// 실패한 지훈이의 움직임인지 확인
		if (time >= 0 && map[y][x] == 'F') continue;

		if (map[y][x] == 'J') { // 지훈이의 움직임일 경우
			for (int i = 0; i < 4; i++) {
				int nxtY = y + dy[i];
				int nxtX = x + dx[i];

				if (0 > nxtY || nxtY > R + 1 || 0 > nxtX || nxtX > C + 1) continue;

				if (map[nxtY][nxtX] == '#' || map[nxtY][nxtX] == 'F') continue;
			
				if (!chk[nxtY][nxtX]) {
					map[nxtY][nxtX] = 'J';
					q.push({ nxtY, nxtX, time + 1 });

					chk[nxtY][nxtX] = true; // 갔던 곳을 다시 방문하지 않는다.
				}
			}
		}
		else { // 불의 움직임일 경우
			for (int i = 0; i < 4; i++) {
				int nxtY = y + dy[i];
				int nxtX = x + dx[i];

				if (1 > nxtY || nxtY > R || 1 > nxtX || nxtX > C) continue;

				if (map[nxtY][nxtX] == '#' || map[nxtY][nxtX] == 'F') continue;

				map[nxtY][nxtX] = 'F';
				q.push({ nxtY, nxtX, -1 });
			}
		}
	}

	cout << "IMPOSSIBLE" << '\n';
	return 0;
}