// 백준 2206 : 벽 부수고 이동하기
#include <vector>
#include <string>
#include <iostream>
#include <queue>

using namespace std;

int n, m;
char map[1001][1001]; // 사용할 인덱스 : 1 ~ 10000
int dx[4] = { 0, 0, 1, -1 };
int dy[4] = { 1, -1, 0, 0 };
bool chk[2][1001][1001]; // 해당 지점까지 벽을 부순적이 있는지 없는지까지 저장

int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> map[i][j];
		}
	}

	queue<vector<int>> q;
	q.push({ 1, 1, 1, 0 }); // {y, x, cnt, broke}

	while (!q.empty()) {
		int y = q.front()[0];
		int x = q.front()[1];
		int cnt = q.front()[2];
		int broke = q.front()[3];
		q.pop();

		if (y == n && x == m) {
			cout << cnt << '\n';
			return 0;
		}

		for (int i = 0; i < 4; i++) {
			int nxtY = y + dy[i];
			int nxtX = x + dx[i];

			if (1 <= nxtY <= n && 1 <= nxtX && nxtX <= m) {
				if (map[nxtY][nxtX] == '0' && !chk[broke][nxtY][nxtX]) { // 벽이 없는 경우
					q.push({ nxtY, nxtX, cnt + 1, broke });
					chk[broke][nxtY][nxtX] = true;
				}
				else if(map[nxtY][nxtX] == '1' && broke == 0) { // 벽이 있지만 한번도 벽을 부순적이 없다면
					q.push({ nxtY, nxtX, cnt + 1, broke+1 });
					chk[broke + 1][nxtY][nxtX] = true;
				}
			}
		}
	}
	cout << -1 << '\n';
	return 0;
}