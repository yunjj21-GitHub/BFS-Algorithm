// 백준 16932 : 모양 만들기
#include <vector>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

int N, M;
int map[1000][1000];
bool chk[1000][1000];
int dy[4] = { 0, 0, 1,-1 };
int dx[4] = { 1, -1, 0, 0 };
int shape[1000 * 1000];

void BFS(int y, int x, int group) {
	queue<pair<int, int>> q;
	q.push({ y, x });
	chk[y][x] = true;
	map[y][x] = group;

	int size = 1;
	while (!q.empty()) {
		int y = q.front().first;
		int x = q.front().second;
		q.pop();

		for (int i = 0; i < 4; i++) {
			int nxtY = y + dy[i];
			int nxtX = x + dx[i];

			if (0 > nxtY || nxtY >= N || 0 > nxtX || nxtX >= M) continue;

			if (map[nxtY][nxtX] == 1 && !chk[nxtY][nxtX]) {
				size++;
				map[nxtY][nxtX] = group;
				chk[nxtY][nxtX] = true;
				q.push({ nxtY, nxtX });
			}
		}
	}
	shape[group] = size;
}

int main() {
	// 입력 받기
	cin >> N >> M;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			cin >> map[i][j];
		}
	}

	// 하나의 모양을 구성하는 1을 하나의 그룹으로 그룹핑 (BFS)
	int group = 0;
	for (int y = 0; y < N; y++) {
		for (int x = 0; x < M; x++) {
			if (map[y][x] == 1 && !chk[y][x]) {
				group++;
				BFS(y, x, group);
			}
		}
	}

	// map == 0인 좌표를 기준으로 완전탐색
	vector<int> ans;
	for (int y = 0; y < N; y++) {
		for (int x = 0; x < M; x++) {
			if (map[y][x] == 0) {
				vector<int> adjGroup; // 현재 탐색중인 좌표와 인접한 그룹들을 저장

				for (int i = 0; i < 4; i++) {
					int nxtY = y + dy[i];
					int nxtX = x + dx[i];

					if (0 > nxtY || nxtY >= N || 0 > nxtX || nxtX >= M) continue;

					if (map[nxtY][nxtX] >= 1) {
						adjGroup.push_back(map[nxtY][nxtX]);
					}
				}

				// 중복해서 들어갔을 그룹을 제거
				sort(adjGroup.begin(), adjGroup.end());
				adjGroup.erase(unique(adjGroup.begin(), adjGroup.end()), adjGroup.end());

				// 현재 탐색중인 좌표와 인접한 그룹들의 크기 합을 계산
				int sum = 0;
				for (int i = 0; i < adjGroup.size(); i++) {
					sum += shape[adjGroup[i]];
				}
				sum += 1; // 현재좌표의 크기
				ans.push_back(sum);
			}
		}
	}

	sort(ans.rbegin(), ans.rend()); // 내림차순 정렬됨
	cout << ans[0] << '\n';
}